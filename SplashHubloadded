-- ====================================================================
-- SplashHub: Rayfield UI çµ±åˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ (æ©Ÿèƒ½é€£å‹•ç‰ˆ)
-- ====================================================================
local P = game:GetService("Players").LocalPlayer;
local UIS = game:GetService("UserInputService");
local RS = game:GetService("RunService");
local WS = game:GetService("Workspace");
local ReplicatedStorage = game:GetService("ReplicatedStorage");

-- UIå¤‰æ•°ã¨ã‚²ãƒ¼ãƒ å¤‰æ•°
local WALK_SPEED = 32;
local FLY_SPEED = 40;
local MAX_FAILURES = 5;
local activeBindings = {}; 
local grabDetectionConnection = nil;
local failureCount = 0;
local isFlying = false;
local isLineExtending = false;
local currentLinePart = nil;
local bodyVelocity = nil;

-- æ´ã¿å›é¿ã«å¿…è¦ãªå®šæ•°ã¨RemoteEvent
local GRAB_DETECTION_OBJECTS = {"BodyPosition", "BodyVelocity", "BodyGyro", "AlignOrientation", "AlignPosition", "Attachment"};
local GRAB_EVENTS = {
    "GrabEvents.ExtendGrabLine", 
    "CharacterEvents.Look",
    "GrabEvents.GrabTarget",
    "GrabEvents.ReleaseGrab",
};
local remoteGrab = ReplicatedStorage:WaitForChild("GrabEvents", 5) and ReplicatedStorage.GrabEvents:WaitForChild("GrabTarget", 5);
local remoteRelease = ReplicatedStorage:WaitForChild("GrabEvents", 5) and ReplicatedStorage.GrabEvents:WaitForChild("ReleaseGrab", 5);

-- Rayfieldã®èª­ã¿è¾¼ã¿
local RAYFIELD_LOADER_URL = "https://sirius.menu/rayfield" 
local Rayfield = nil
local success, result = pcall(function()
    local loader = game:HttpGet(RAYFIELD_LOADER_URL)
    Rayfield = loadstring(loader)()
end)

if not Rayfield or not success then
    warn("Rayfieldã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä¸­æ–­ã—ã¾ã™ã€‚")
    return
end

-- ----------------------------------------------------
-- ğŸ® æ©Ÿèƒ½ãƒ­ã‚¸ãƒƒã‚¯ (ä»¥å‰ã®å®‰å®šç‰ˆã‹ã‚‰ç¶™æ‰¿)
-- ----------------------------------------------------

-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
local function bindToRenderStep(name, priority, func)
    if activeBindings[name] then RS:UnbindFromRenderStep(name) end
    RS:BindToRenderStep(name, priority, func)
    activeBindings[name] = true
end

local function unbindFromRenderStep(name)
    if activeBindings[name] then
        RS:UnbindFromRenderStep(name)
        activeBindings[name] = nil
    end
end

-- é€šçŸ¥æ©Ÿèƒ½ (ç°¡ç•¥åŒ–)
local function showNotification(message)
    if Rayfield.Notify then
        Rayfield.Notify({Title = "SplashHub", Content = message, Duration = 3})
    end
end

-- æ´ã¿/é˜²å¾¡RemoteEventã®ç„¡åŠ¹åŒ–ï¼ˆHookï¼‰
local function hookGrabEvents()
    for _, path in pairs(GRAB_EVENTS) do
        local parts = string.split(path, ".");
        local eventName = table.remove(parts);
        local current = ReplicatedStorage;

        for _, part in ipairs(parts) do
            current = current:WaitForChild(part, 3);
            if not current then break end
        end

        local event = current and current:FindFirstChild(eventName);

        if event and event:IsA("RemoteEvent") then
            pcall(function()
                event.OnClientEvent:Connect(function() end);
            end)
        end
    end
    showNotification("å…¨ã¦ã®é˜²å¾¡ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ•ãƒƒã‚¯ã—ã¾ã—ãŸã€‚")
end

-- Lineè·é›¢åˆ¶é™è§£é™¤æ©Ÿèƒ½ã®ãƒ­ã‚¸ãƒƒã‚¯
local function startLineExtension()
    if isLineExtending then return end;

    local Root = P.Character and P.Character:FindFirstChild("HumanoidRootPart");
    if not Root then showNotification("ã‚¨ãƒ©ãƒ¼: ãƒ©ã‚¤ãƒ³ã®èµ·ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"); return end;

    isLineExtending = true;

    currentLinePart = Instance.new("Part");
    pcall(function()
        currentLinePart.Parent = WS;
        currentLinePart.Anchored = true;
        currentLinePart.CanCollide = false;
        currentLinePart.BrickColor = BrickColor.new("Really red");
        currentLinePart.Material = Enum.Material.ForceField;
        currentLinePart.Transparency = 0.5;
        currentLinePart.Name = "InfiniteGrabLine"
    end)

    bindToRenderStep("LineExtension", Enum.RenderPriority.Camera.Value + 1, function()
        if not isLineExtending or not currentLinePart or not Root or not WS.CurrentCamera then return end

        local mouseRay = WS.CurrentCamera:ScreenPointToRay(UIS:GetMouseLocation().X, UIS:GetMouseLocation().Y);
        local targetPos = mouseRay.Origin + mouseRay.Direction * 10000; 

        local startPos = Root.Position;
        local distance = (targetPos - startPos).Magnitude;

        pcall(function()
            currentLinePart.Size = Vector3.new(0.2, 0.2, distance);
            currentLinePart.CFrame = CFrame.new(startPos, targetPos) * CFrame.new(0, 0, -distance / 2);
        end)
    end)
    showNotification("Lineæ‹¡å¼µ ON: ãƒã‚¦ã‚¹ã§æ´ã¿ã€å³ã‚¯ãƒªãƒƒã‚¯ã§ãƒªãƒªãƒ¼ã‚¹")
end

local function stopLineExtension()
    if not isLineExtending then return end
    isLineExtending = false;
    unbindFromRenderStep("LineExtension");

    if currentLinePart then
        pcall(currentLinePart.Destroy, currentLinePart);
        currentLinePart = nil;
    end
    showNotification("Lineæ‹¡å¼µ OFF")
end

-- å¼·åˆ¶æ´ã¿å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯ (UIãƒˆã‚°ãƒ«ã¨ã¯ç‹¬ç«‹ã—ã¦å®Ÿè¡Œ)
UIS.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent or not isLineExtending or not remoteGrab or not remoteRelease then return end

    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local mouseRay = WS.CurrentCamera:ScreenPointToRay(UIS:GetMouseLocation().X, UIS:GetMouseLocation().Y);
        local forcedTargetPos = mouseRay.Origin + mouseRay.Direction * 5000; 
        
        pcall(remoteGrab.FireServer, remoteGrab, forcedTargetPos, forcedTargetPos);
    elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
        pcall(remoteRelease.FireServer, remoteRelease);
    end
end)


-- é£›è¡Œæ©Ÿèƒ½
local function stopFlying()
    if not isFlying then return end
    isFlying = false; failureCount = 0;
    unbindFromRenderStep("AntiAC");
    local H = P.Character and P.Character:FindFirstChildOfClass("Humanoid");
    if H and H.Parent then pcall(function() H.WalkSpeed = WALK_SPEED end) end;
    if bodyVelocity and bodyVelocity.Parent then pcall(bodyVelocity.Destroy, bodyVelocity); bodyVelocity = nil end;
    showNotification("é£›è¡Œ OFF")
}

local function startFlying()
    if isFlying then return end;
    local H = P.Character and P.Character:FindFirstChildOfClass("Humanoid");
    local Root = P.Character and P.Character:FindFirstChild("HumanoidRootPart");
    if not H or not Root or not Root.Parent then showNotification("ã‚¨ãƒ©ãƒ¼: ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"); return end;
    isFlying = true;
    pcall(function() H.WalkSpeed = 0 end)
    
    if not bodyVelocity or not bodyVelocity.Parent then
        bodyVelocity = Root:FindFirstChildOfClass("BodyVelocity") or Instance.new("BodyVelocity");
        bodyVelocity.MaxForce = Vector3.new(1, 1, 1) * 9e9; bodyVelocity.P = 1000;
        pcall(function() bodyVelocity.Parent = Root end)
    end
    
    bindToRenderStep("AntiAC", Enum.RenderPriority.Camera.Value, function()
        if not P.Character or not Root or not Root.Parent or not H or not H.Parent then stopFlying(); return end;
        if H.WalkSpeed ~= 0 then
            pcall(function() H.WalkSpeed = 0 end)
            if H.WalkSpeed ~= 0 then
                failureCount = failureCount + 1;
                if failureCount >= MAX_FAILURES then showNotification("ã‚¢ãƒ³ãƒãƒãƒ¼ãƒˆæ¤œå‡ºã€‚é£›è¡Œã‚’è§£é™¤ã—ã¾ã™ã€‚"); stopFlying(); return end
            end
        else failureCount = 0; end
        if bodyVelocity and not bodyVelocity.Parent then pcall(function() bodyVelocity.Parent = Root end); end;
    end);
    showNotification("é£›è¡Œ ON")
}

local function updateFlyMovement()
    if not isFlying or not P.Character then stopFlying(); return end
    local H = P.Character:FindFirstChildOfClass("Humanoid");
    local Root = P.Character:FindFirstChild("HumanoidRootPart");
    if not H or not Root or not bodyVelocity or not bodyVelocity.Parent then stopFlying(); return end

    local C = WS.CurrentCamera; if not C then return end;
    local CF_ = C.CFrame; local mV = Vector3.new(0, 0, 0);
    if UIS:IsKeyDown(Enum.KeyCode.W) then mV = mV + CF_.LookVector end;
    if UIS:IsKeyDown(Enum.KeyCode.S) then mV = mV - CF_.LookVector end;
    if UIS:IsKeyDown(Enum.KeyCode.A) then mV = mV - CF_.RightVector end;
    if UIS:IsKeyDown(Enum.KeyCode.D) then mV = mV + CF_.RightVector end;
    if UIS:IsKeyDown(Enum.KeyCode.Space) then mV = mV + Vector3.new(0, 1, 0) end;
    if UIS:IsKeyDown(Enum.KeyCode.LeftShift) or UIS:IsKeyDown(Enum.KeyCode.RightShift) then mV = mV - Vector3.new(0, 1, 0) end;
    if mV.Magnitude > 0 then
        pcall(function() bodyVelocity.Velocity = mV.unit * FLY_SPEED end);
    else
        pcall(function() bodyVelocity.Velocity = Vector3.new(0, 0, 0) end);
    end;
end;


local function updateAntiRagdoll()
    local H = P.Character and P.Character:FindFirstChildOfClass("Humanoid");
    if H and H.Parent and H.PlatformStand == true then
         pcall(function() H.PlatformStand = false; end);
    end
end;

local function setupGrabDetection(rootPart)
    if grabDetectionConnection and grabDetectionConnection.Connected then grabDetectionConnection:Disconnect(); end
    grabDetectionConnection = rootPart.ChildAdded:Connect(function(child)
        for _, name in pairs(GRAB_DETECTION_OBJECTS) do
            if child.ClassName == name and child.Parent == rootPart then
                showNotification("æ´ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ¿å…¥æ¤œå‡ºï¼è„±å‡ºã‚’è©¦ã¿ã¾ã™ã€‚");
                pcall(child.Destroy, child);
            end
        end
    end);
end

local function disableTargetScript()
    local playerScripts = P:FindFirstChild("PlayerScripts");
    if not playerScripts then return end
    local targetScript = playerScripts:FindFirstChild("CharacterAndBeamMove");
    if targetScript then
        pcall(function() targetScript:Destroy(); end)
    end
end

local function setupCharacter(character)
    local H = character:FindFirstChildOfClass("Humanoid");
    if H then pcall(function() H.WalkSpeed = WALK_SPEED end) end;

    local Root = character:FindFirstChild("HumanoidRootPart");
    if Root then setupGrabDetection(Root) end;

    -- é£›è¡Œç§»å‹•ãƒ«ãƒ¼ãƒ—ã¨ã‚¢ãƒ³ãƒãƒ©ã‚°ãƒ‰ãƒ¼ãƒ«ã‚’å†ãƒã‚¤ãƒ³ãƒ‰
    bindToRenderStep("FlyMovement", Enum.RenderPriority.Character.Value, updateFlyMovement);
    bindToRenderStep("AntiRagdoll", Enum.RenderPriority.Camera.Value - 1, updateAntiRagdoll);
end

-- ----------------------------------------------------
-- ğŸ¨ Rayfield UI å®šç¾©
-- ----------------------------------------------------

local Window = Rayfield:CreateWindow({
    Name = "ã±ã‚‹ã®è¶…çµ¶UI",
    LoadingTitle = "èª­ã¿è¾¼ã¿ä¸­â€¦",
    LoadingSubtitle = "Rayfield v3",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "MyAwesomeUI"
    }
})

local MainTab = Window:CreateTab("ãƒ¡ã‚¤ãƒ³", 4483362458)
local FlightSection = MainTab:CreateSection("é£›è¡Œ")

FlightSection:CreateToggle({
    Name = "Infinite Flight (é£›è¡Œ)",
    CurrentValue = false,
    Flag = "InfiniteFlightFlag",
    Callback = function(toggled)
        if toggled then
            startFlying()
        else
            stopFlying()
        end
    end,
})

FlightSection:CreateSlider({
    Name = "Fly Speed",
    Range = {1, 150},
    Increment = 5,
    Suffix = "Studs/s",
    CurrentValue = FLY_SPEED,
    Flag = "FlySpeedFlag",
    Callback = function(value)
        FLY_SPEED = value
        showNotification("é£›è¡Œé€Ÿåº¦ã‚’ "..value.." ã«è¨­å®š")
    end,
})

local BypassSection = MainTab:CreateSection("å›é¿ & ä¿è­·")

BypassSection:CreateToggle({
    Name = "Anti-Ragdoll (è‡ªå‹•è§£é™¤)",
    CurrentValue = true, -- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ONã«æ¨å¥¨
    Flag = "AntiRagdollFlag",
    Callback = function(toggled)
        -- ãƒ­ã‚¸ãƒƒã‚¯ã¯å¸¸ã«RunServiceã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒˆã‚°ãƒ«ã¯UIè¡¨ç¤ºç”¨ã¨ã—ã¦æ‰±ã†ã€‚
        showNotification("ã‚¢ãƒ³ãƒãƒ©ã‚°ãƒ‰ãƒ¼ãƒ«ã¯å¸¸ã«æœ‰åŠ¹ã§ã™ã€‚")
    end,
})

BypassSection:CreateToggle({
    Name = "Grab Hook (æ´ã¿ç„¡åŠ¹åŒ–)",
    CurrentValue = true, -- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ONã«æ¨å¥¨
    Flag = "GrabHookFlag",
    Callback = function(toggled)
        if toggled then
            hookGrabEvents()
        else
            -- UIä¸Šã§ã¯OFFã«ã—ã¦ã‚‚ã€ä¸€åº¦ãƒ•ãƒƒã‚¯ã™ã‚‹ã¨è§£é™¤ã¯ã§ããªã„ãŸã‚ã€æ³¨æ„å–šèµ·ã®ã¿
            showNotification("RemoteEventã®ãƒ•ãƒƒã‚¯ã¯è§£é™¤ã§ãã¾ã›ã‚“ã€‚", 3)
        end
    end,
})

local GrabSection = MainTab:CreateSection("ãƒ©ã‚¤ãƒ³æ“ä½œ")

GrabSection:CreateToggle({
    Name = "Infinite Grab Distance (ãƒ©ã‚¤ãƒ³æ‹¡å¼µ)",
    CurrentValue = isLineExtending,
    Flag = "InfiniteGrabFlag",
    Callback = function(toggled)
        if toggled then
            startLineExtension()
        else
            stopLineExtension()
        end
    end,
})


-- ----------------------------------------------------
-- âš™ï¸ åˆæœŸåŒ–ã‚·ãƒ¼ã‚±ãƒ³ã‚¹
-- ----------------------------------------------------
local function initialize()
    -- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒ­ãƒ¼ãƒ‰ã‚’å¾…ã¤
    local character = P.Character or P.CharacterAdded:Wait()
    
    -- åˆå›èµ·å‹•æ™‚ã«æ´ã¿ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ•ãƒƒã‚¯ã—ã€ã‚²ãƒ¼ãƒ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç„¡åŠ¹åŒ–
    hookGrabEvents();
    disableTargetScript();
    
    -- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒãƒªã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹ãŸã³ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
    P.CharacterAdded:Connect(setupCharacter);
    setupCharacter(character);
    
    -- åˆå›ãƒ­ãƒ¼ãƒ‰å®Œäº†é€šçŸ¥
    showNotification("ã±ã‚‹ã®è¶…çµ¶UI èµ·å‹•å®Œäº†ï¼", 5)
end

pcall(initialize)
